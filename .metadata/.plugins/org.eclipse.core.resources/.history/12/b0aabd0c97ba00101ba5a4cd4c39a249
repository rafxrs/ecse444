/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stm32l4s5i_iot01_tsensor.h"
#include "stm32l4s5i_iot01_psensor.h"
#include "stm32l4s5i_iot01_magneto.h"
#include "stm32l4s5i_iot01_accelero.h"
#include "stm32l4s5i_iot01_qspi.h"
#include <string.h>
#include <stdio.h>

// External handles from main.c
extern UART_HandleTypeDef huart1;
extern I2C_HandleTypeDef hi2c2;
extern OSPI_HandleTypeDef hospi1;
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
volatile float temp;
volatile float pressure;
volatile int16_t mag_data[3];
volatile int16_t accel_data[3];
extern volatile uint8_t sensor_mode;
static uint8_t printed_summary = 0;
#define MAX_SAMPLES   256   // per sensor (fits easily in 64 KB block)
#define FLASH_ADDR_BASE  0x000000  // start of flash region

typedef struct {
    uint32_t count;
    float mean_temp, M2_temp;
    float mean_press, M2_press;
    float mean_mag[3], M2_mag[3];
    float mean_acc[3], M2_acc[3];
} RunningStats;

static RunningStats stats;
typedef struct {
    float temp[LOG_BATCH_SIZE];
    float pressure[LOG_BATCH_SIZE];
    int16_t mag[LOG_BATCH_SIZE][3];
    int16_t accel[LOG_BATCH_SIZE][3];
} SensorLog;

/* USER CODE END Variables */
osThreadId defaultTaskHandle;
osThreadId sensorTaskHandle;
osThreadId buttonTaskHandle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void const * argument);
void StartSensorTask(void const * argument);
void StartButtonTask(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 256);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* definition and creation of sensorTask */
  osThreadDef(sensorTask, StartSensorTask, osPriorityNormal, 0, 256);
  sensorTaskHandle = osThreadCreate(osThread(sensorTask), NULL);

  /* definition and creation of buttonTask */
  osThreadDef(buttonTask, StartButtonTask, osPriorityLow, 0, 128);
  buttonTaskHandle = osThreadCreate(osThread(buttonTask), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartDefaultTask */
/**
  * @brief  Function implementing the defaultTask thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
  /* USER CODE BEGIN StartDefaultTask */
  /* Infinite loop */
	  char output[64];

	  for(;;)
	  {
		osDelay(100);
	    int t = (int)(temp + 0.5f);
	    int p = (int)(pressure + 0.5f);

	    switch(sensor_mode)
	    {
	      case 0: {
	    	  printed_summary = 0;
	    	  flash_addr = FLASH_ADDR_BASE;
	    	  BSP_QSPI_Erase_Block(flash_addr);
	    	  sprintf(output, "Temp = %d C\r\n", t);
	    	  HAL_UART_Transmit(&huart1, (uint8_t*)output, strlen(output), 100);
	    	  break;
	      }
	      case 1: {
	    	  sprintf(output, "Press = %d hPa\r\n", p);
	    	  HAL_UART_Transmit(&huart1, (uint8_t*)output, strlen(output), 100);
	    	  break;
	      }
	      case 2: {
	    	  sprintf(output, "Mag [mG] X=%d Y=%d Z=%d\r\n",mag_data[0], mag_data[1], mag_data[2]);
	    	  HAL_UART_Transmit(&huart1, (uint8_t*)output, strlen(output), 100);
	    	  break;
	      }
	      case 3: {
	    	  sprintf(output, "Accel [mg] X=%d Y=%d Z=%d\r\n",accel_data[0], accel_data[1], accel_data[2]);
	    	  HAL_UART_Transmit(&huart1, (uint8_t*)output, strlen(output), 100);
	    	  break;
	      }
	      case 4:
	          if (!printed_summary) {
	              printed_summary = 1;

	              // running sums for stats
	              float sumT = 0, sumP = 0, sumT2 = 0, sumP2 = 0;
	              float sumMag[3] = {0}, sumMag2[3] = {0};
	              float sumAcc[3] = {0}, sumAcc2[3] = {0};
	              uint32_t totalSamples = 0;

	              SensorLog readBuf;
	              uint32_t addr = FLASH_ADDR_BASE;

	              // Read back all logged samples
	              while (addr < flash_addr) {
	                  BSP_QSPI_Read((uint8_t*)&readBuf, addr, sizeof(SensorLog));
	                  while (BSP_QSPI_GetStatus() != QSPI_OK);
	                  addr += sizeof(SensorLog);

	                  for (int i = 0; i < LOG_BATCH_SIZE; i++) {
	                      float t = readBuf.temp[i];
	                      float p = readBuf.pressure[i];
	                      sumT += t; sumT2 += t * t;
	                      sumP += p; sumP2 += p * p;

	                      for (int k = 0; k < 3; k++) {
	                          float m = readBuf.mag[i][k];
	                          float a = readBuf.accel[i][k];
	                          sumMag[k] += m; sumMag2[k] += m * m;
	                          sumAcc[k] += a; sumAcc2[k] += a * a;
	                      }
	                      totalSamples++;
	                  }
	              }

	              // Compute means and variances
	              float meanT = sumT / totalSamples;
	              float varT  = (sumT2 / totalSamples) - (meanT * meanT);
	              float meanP = sumP / totalSamples;
	              float varP  = (sumP2 / totalSamples) - (meanP * meanP);

	              char msg[128];
	              sprintf(msg, "\r\nSamples: %lu\r\n", totalSamples);
	              HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 100);

	              sprintf(msg, "Temp mean=%d var=%d\r\n", (int)meanT, (int)varT);
	              HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 100);

	              sprintf(msg, "Press mean=%d var=%d\r\n", (int)meanP, (int)varP);
	              HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 100);

	              const char* axis[3] = {"X", "Y", "Z"};
	              for (int k = 0; k < 3; k++) {
	                  float meanM = sumMag[k] / totalSamples;
	                  float varM  = (sumMag2[k] / totalSamples) - (meanM * meanM);
	                  float meanA = sumAcc[k] / totalSamples;
	                  float varA  = (sumAcc2[k] / totalSamples) - (meanA * meanA);

	                  sprintf(msg, "Mag[%s] mean=%d var=%d\r\n", axis[k], (int)meanM, (int)varM);
	                  HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 100);
	                  sprintf(msg, "Acc[%s] mean=%d var=%d\r\n", axis[k], (int)meanA, (int)varA);
	                  HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 100);
	              }
	          }
	          break;

	    }

	  }
  /* USER CODE END StartDefaultTask */
}

/* USER CODE BEGIN Header_StartSensorTask */
/**
* @brief Function implementing the sensorTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartSensorTask */
void StartSensorTask(void const * argument)
{
  /* USER CODE BEGIN StartSensorTask */
	/* Infinite loop */
	for(;;)
	{
		osDelay(100); // 10 Hz
		temp = BSP_TSENSOR_ReadTemp();
		pressure = BSP_PSENSOR_ReadPressure();
		BSP_MAGNETO_GetXYZ((int16_t*)mag_data);
		BSP_ACCELERO_AccGetXYZ((int16_t*)accel_data);

		stats.count += 1;

		// Temperature
		float d = temp - stats.mean_temp;
		stats.mean_temp += d / stats.count;
		stats.M2_temp += d * (temp - stats.mean_temp);

		// Pressure
		d = pressure - stats.mean_press;
		stats.mean_press += d / stats.count;
		stats.M2_press += d * (pressure - stats.mean_press);

		// Magnetometer and accelerometer (per axis)
		for (int i = 0; i < 3; i++) {
		    float xm = mag_data[i];
		    float xa = accel_data[i];

		    float dm = xm - stats.mean_mag[i];
		    stats.mean_mag[i] += dm / stats.count;
		    stats.M2_mag[i] += dm * (xm - stats.mean_mag[i]);

		    float da = xa - stats.mean_acc[i];
		    stats.mean_acc[i] += da / stats.count;
		    stats.M2_acc[i] += da * (xa - stats.mean_acc[i]);
		}

	}
  /* USER CODE END StartSensorTask */
}

/* USER CODE BEGIN Header_StartButtonTask */
/**
* @brief Function implementing the buttonTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartButtonTask */
void StartButtonTask(void const * argument)
{
  /* USER CODE BEGIN StartButtonTask */
  /* Infinite loop */
  for(;;)
  {
	  osDelay(1);
  }
  /* USER CODE END StartButtonTask */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */
